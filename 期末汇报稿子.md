# 12306 自动化测试与系统实现 - 期末汇报演讲稿 (学生版)

**汇报人**：[您的姓名]
**总时长**：10分钟
**适用场景**：期末课程汇报

---

### 一、 开场与项目概况 【预计用时：45秒】

**(PPT 第 1-2 页)**

**[各位老师、同学，大家好]**

我是[您的姓名]，今天我汇报的期末大作业主题是**《基于 LLM 驱动与 WebTestPilot 的 12306 自动化测试系统实战》**。

在本次课程实践中，我尝试复现了一个 12306 购票系统。但更重要的是，我想通过这个项目，探索在 AI 辅助编程的背景下，如何实现**“全链路需求追踪”**与**“工程化测试驱动”**的开发模式。

请看 **PPT 第 2 页**，这是我的项目概览。我的系统覆盖了从注册登录到支付出票的完整业务闭环。为了保证质量，我构建了包含 **36** 个系统级需求 ID 的追踪体系，并编写了 **60** 个自动化测试脚本。我的初衷是希望解决在过往开发中经常遇到的“文档写完就扔，代码跟文档脱节”的问题。

接下来，为了让大家对我的工作成果有一个直观的认识，我准备了一段系统实机演示视频。

---

### 二、 系统演示环节 (Demo) 【总时长：3分15秒】

**(PPT 第 3 页)**

#### 1. 演示导语 【预计用时：15秒】
**[请播放演示视频]**
大家即将看到的是一段 3 分钟的未剪辑实录。这段视频展示了我的自动化测试脚本是如何驱动浏览器，像真实用户一样完成从“账号注册”到“购票支付”的全流程的。

#### 2. 〖视频演示内容〗 【时长：3分00秒】
*(注：以下为视频播放时的旁白配合建议，不计入口头讲解时长)*

*   **[00:00-00:45] 注册与登录模块**：现在演示的是自动化脚本输入用户信息。这里触发了“密码强度校验”与“必填项拦截”。大家可以看到，脚本能够自动识别前端的错误提示并进行处理。
*   **[00:45-01:30] 车票查询与筛选**：接着是查票环节。脚本选择了“上海”到“北京”，并勾选了“高铁”和“商务座”。这里展示了我对“原子级需求”的控制能力。
*   **[01:30-02:15] 订单提交与乘客选择**：现在添加乘车人“张三”，并处理了“重复添加”的异常弹窗，随后提交订单。
*   **[02:15-03:00] 模拟支付与状态变更**：请注意下方的控制台日志，显示 API 状态码从 200 变为 201，订单状态由“待支付”变更为“已完成”。

#### 3. 演示总结 【预计用时：15秒】
**〖视频结束〗**
通过刚才的演示，可以看到 WebTestPilot 框架成功实现了对 GUI 的稳定控制。这不仅验证了我的系统功能是可用的，也侧面证明了 TDD（测试驱动开发）模式在本项目中的有效性。

---

### 三、 需求管理：原子级的精准把控 【预计用时：1分30秒】

**(PPT 第 4-5 页)**

**[接下来，我想分享一下我在需求管理上的思考]**

在以前的项目中，我往往只关注“功能有没有做出来”，而忽略了需求的精细化管理。在本项目中，我尝试建立了一套**“L1-L2-L3”的三层需求管理体系**。

请看 **PPT 第 5 页**。我将 5 大核心业务模块，细分为了 **30** 个具体的功能特性。更进一步，我将每一个测试步骤都拆解为“原子需求”。

什么是**“原子级需求”**？
以“车票查询”为例，我将其拆解为 **103** 个细分点。比如“点击出发地输入框应弹出面板”、“勾选复兴号应实时过滤”等。目前，我总共梳理了 **200+** 个这样的原子需求点。

这种颗粒度的管理，让我实现了**“基于代码的需求追踪”**。每一个需求点都能在代码中找到对应的 `REQ-ID`，确保了没有任何一个业务逻辑是“凭空产生”的。

---

### 四、 设计思路：PRD 闭环迭代 【预计用时：2分30秒】

**(PPT 第 6-7 页)**

**[有了精准的需求，我是如何实现的呢？]**

我采用了一种**“PRD 闭环迭代”**的设计思路，如图 **PPT 第 6 页** 所示。这不仅仅是线性的开发流程，而是一个**“双向修正”**的闭环系统，我将其分为五个阶段：

**第一阶段：PRD 1.0 定义**。我首先撰写了初始需求文档，明确业务目标。

**第二阶段：初稿实现**。利用 LLM 基于 PRD 生成代码初稿。在这一步，我得到了基础的代码框架。

**第三阶段：问题发现**。这是我感触最深的一环。通过运行代码和初步测试，我发现了不少逻辑漏洞。

*   **传统 PRD 开发模式的痛点**。
*   在传统的瀑布流或简单敏捷开发中，PRD 往往是**“一次性交付物”**。产品经理写完文档扔给开发，开发写完代码扔给测试。一旦进入编码阶段，**PRD 就变成了“死文档”**。
*   这就导致了严重的**“需求与实现分离”**：代码里明明已经改了逻辑（比如为了修复 bug 增加的校验），但文档里根本没体现。新人接手项目时，看文档是错的，看代码又看不懂业务初衷，维护成本极高。
*   回到本项目，**举个真实的例子**：在开发注册模块时，我发现初始代码虽然能提交表单，但**未校验“确认密码”与“密码”的一致性**，导致我测试时经常因为手误注册了错误的密码。

**第四阶段：Prompt 修正与反哺**。这是我觉得最有意思的创新点，也是为了解决上述痛点。
*   当我发现这个问题时，我**没有直接去改代码**。
*   相反，我设计了一个 Prompt：“请修正代码，增加密码一致性校验。同时，**请指出原 PRD 中关于‘密码校验’部分的缺失**。”
*   通过这种方式，我不仅修复了 bug，更**反向更新了 PRD 文档**。这确保了我的文档永远是“活”的，与代码保持同步。

**第五阶段：测试验证**。基于修正后的 PRD，我更新了自动化测试用例，并利用原子化步骤和环境隔离技术，正在向测试的**“稳定复现”**稳步前进。

如 **PPT 第 7 页** 所示，通过唯一的 `REQ-ID`，我将**用户需求**、**前端 UI**、**后端 API**以及**测试用例**彻底打通了。

---

### 五、 挑战与解决方案：工程化 AI 治理 【预计用时：1分40秒】

**(PPT 第 8-9 页)**

**[当然，在 AI 辅助开发的过程中，我也踩了不少坑]**

正如 **PPT 第 8 页** 所提到的，主要面临两大难题：

**第一是“模型幻觉”**。
当我试图让 AI 生成复杂的订单模块时，它经常“臆造”不存在的 API。
**我的解决方案**是**“接口先行”**。我强制 AI 必须严格遵循我预定义的 YAML 接口签名，给 AI 戴上“镣铐”，并采用**“原子化拆解”**策略，每次只生成一个具体的函数，从而大幅降低了幻觉率。

**第二是“数据库管理混乱”**。
AI 经常随意修改表结构或插入脏数据，导致我的测试环境被污染。
**解决方案**见 **PPT 第 9 页**，我实施了**“测试环境沙箱化”**。利用 SQLite 的文件特性，实现“测试即重置”，每次测试前自动回滚到黄金快照，确保环境的绝对纯净。

此外，针对 GUI 测试的不稳定性，我在 `run_tests.py` 中实现了**自动重试机制**。

---

### 六、 测试运行情况与总结 【预计用时：1分20秒】

**(PPT 第 10-11 页)**

**[最后，汇报一下目前的测试成果]**

根据 **PPT 第 10 页** 的测试报告，我的自动化测试已经 **100% 覆盖** 了 12306 的核心业务流程。
通过在 `run_tests.py` 中对每个 GUI 测试进行 3 次自动超时重试，目前能够达到 **30 个测试用例全部通过**。这包含核心的正向流程以及密码错误、库存不足等异常场景。

**(PPT 第 11 页)**

**[总结]**
通过这个项目，我不仅复现了 12306 系统，更探索出了一套**“原子需求管理 + 闭环迭代设计 + 工程化 AI 治理”**的方法论。这个过程让我深刻体会到，在 AI 时代，严谨的工程化约束依然是我们构建高质量软件的基石。

以上就是我的汇报，感谢各位老师和同学的聆听，欢迎提问！

---

### 💡 演讲提示
1.  **【】** 内的时间为累计参考时间，请在排练时注意把控。
2.  **加粗文字** 为重音强调部分，建议在演讲时通过停顿或提高音量来突出。
3.  **PPT 页码引用** 是为了引导观众视线，请配合激光笔或手势指示屏幕。
4.  提到“30个测试用例全部通过”时，语调要自信，这是对挑战部分的有力回应。
